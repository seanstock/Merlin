# Task ID: 7
# Title: Screen-Time Economy and Gamification System
# Status: pending
# Dependencies: 3, 4, 5, 6
# Priority: medium
# Description: Implement the screen-time wallet, badges, XP system, and adaptive difficulty mechanism to maintain ~80% task success rate, following the 'Internal-First, External-Ready' service-oriented architecture.
# Details:
# Service-Oriented Architecture Approach

- Design all economy services with external API interfaces from day 1
- Implement locally first for rapid development and testing
- Use dependency injection for easy swapping between local/remote implementations
- Structure code to support future extraction to Hostinger VPS
- Build standardized educational content contracts for third-party integration

## Architecture Layers
1. **Service Layer**: Pure DTOs with no Android dependencies, fully serializable
2. **Repository Layer**: Maps between service DTOs and database entities
3. **Database Layer**: Room entities for local persistence

## Core Economy Design
- Base unit: 1 Second = 1 Merlin Coin (MC)
- Display format: Show both MC and time equivalent (e.g., "900 MC (15m)") to help with mental calculation

## Earning Mechanisms
- Basic tasks: 30-60 MC
- Perfect completion: 1.5x multiplier
- First try bonus: +15 MC
- New concepts: 2x multiplier
- Teaching mode: +30 MC bonus
- Daily caps by age group:
  * 3-5 years: 1,800 MC (30 min)
  * 6-8 years: 2,700 MC (45 min)
  * 9-12 years: 3,600 MC (60 min)

## Spending Categories
- Entertainment: 1:1 ratio (1 MC = 1 second)
- Educational games: 0.8:1 discount (1 MC = 1.25 seconds)
- Creative apps: 0.7:1 discount (1 MC = 1.43 seconds)
- Physical activity: 0.5:1 discount (1 MC = 2 seconds)
- Customization unlocks: 300-900 MC
- Learning enhancements: Unlimited spending

## Real-World Value
- Integration with Task 22 (Amazon Affiliate)
- Conversion rate: 25:1 MC-to-cents (2,500 MC = $1)

## Implementation

1. Define Service DTOs (Pure, no Android dependencies):
```kotlin
data class TransactionDto(
    val id: String,  // UUID string, not auto-generated Long
    val childId: String,
    val amount: Int,
    val category: String,
    val description: String,
    val timestamp: String,  // ISO 8601 string
    val metadata: Map<String, String> = emptyMap()
)

data class BalanceDto(
    val childId: String,
    val balance: Int,
    val dailyCap: Int,
    val todayEarned: Int,
    val todaySpent: Int
)

data class BadgeDto(
    val id: String,
    val childId: String,
    val name: String,
    val description: String,
    val earnedAt: String,  // ISO 8601 string
    val category: String,
    val imageUrl: String,
    val benefits: Map<String, String> = emptyMap()
)

data class ExperienceDto(
    val childId: String,
    val level: Int,
    val currentXp: Int,
    val nextLevelXp: Int,
    val totalXpEarned: Int
)

data class PerformanceStatsDto(
    val childId: String,
    val subject: String,
    val successRate: Float,
    val averageDifficulty: Float,
    val tasksCompleted: Int,
    val lastUpdated: String  // ISO 8601 string
)
```

2. Define Service Interfaces (Pure business logic contracts):
```kotlin
interface EconomyService {
    suspend fun recordTransaction(transaction: TransactionDto): Result<TransactionDto>
    suspend fun getBalance(childId: String): Result<BalanceDto>
    suspend fun getTransactionHistory(childId: String): Result<List<TransactionDto>>
    suspend fun getDailyCapByAge(age: Int): Result<Int>
    suspend fun calculateReward(difficulty: Int, isFirstTry: Boolean, isPerfect: Boolean, isNewConcept: Boolean, isTeachingMode: Boolean): Result<Int>
    suspend fun convertToRealWorldValue(coins: Int): Result<Float>
}

interface BadgeService {
    suspend fun awardBadge(badge: BadgeDto): Result<BadgeDto>
    suspend fun getBadges(childId: String): Result<List<BadgeDto>>
    suspend fun hasBadge(childId: String, badgeId: String): Result<Boolean>
}

interface ExperienceService {
    suspend fun awardXp(childId: String, amount: Int, source: String): Result<ExperienceDto>
    suspend fun getExperience(childId: String): Result<ExperienceDto>
}

interface AdaptiveDifficultyService {
    suspend fun calculateTaskDifficulty(childId: String, subject: String): Result<Int>
    suspend fun recordTaskResult(childId: String, subject: String, difficulty: Int, success: Boolean): Result<Unit>
    suspend fun getPerformanceStats(childId: String, subject: String): Result<PerformanceStatsDto>
}
```

## Current Implementation Status

- Complete interface layer exists (EconomyService, BadgeService, etc. + all DTOs)
- Basic EconomyState infrastructure exists and integrates with existing database
- LocalEconomyService_recovery.kt file is ready to be integrated
- Need to implement actual service implementations based on existing infrastructure

## Integration Strategy

- Build on existing codebase (EconomyState, ChildProfile, MerlinDatabase)
- Use recovery file as foundation for implementation
- Extend existing infrastructure rather than creating parallel systems
- Test each component thoroughly before moving to the next
- Focus on core functionality: earning and spending screen time

# Test Strategy:
1. Unit test service layer:
   - Test all service interfaces with mock repositories
   - Verify all business logic functions correctly (rewards, caps, conversions)
   - Test error handling and Result wrapping
   - Ensure service layer has no Android dependencies

2. Unit test repository layer:
   - Test DTO â†” Entity mapping functions
   - Verify repositories correctly transform between service and database layers
   - Test repository error handling and Result wrapping

3. Unit test database layer:
   - Test Room DAOs with in-memory database
   - Verify entity relationships and constraints
   - Test database migrations if extending existing schema

4. Integration tests:
   - Test complete flow from service call through repository to database and back
   - Verify dependency injection correctly provides service implementations
   - Test switching between local and remote implementations

5. API contract tests:
   - Verify service interfaces maintain backward compatibility
   - Test serialization/deserialization of DTOs for API transport
   - Validate that DTOs are fully serializable with no Android dependencies

6. Service transition tests:
   - Test seamless switching between local and remote implementations
   - Verify data consistency when migrating between service implementations

7. User testing:
   - Verify parents understand the economy system
   - Test children's engagement with rewards
   - Ensure the 80% success rate target is maintained

8. Externalization tests:
   - Verify DTOs can be properly serialized/deserialized for network transport
   - Test that service interfaces work identically with both local and remote implementations
   - Validate that no Android dependencies leak into the service layer

# Subtasks:
## 1. Core Economy Implementation [pending]
### Dependencies: None
### Description: Build the complete working economy system using existing EconomyState infrastructure and user's recovery file
### Details:
INTEGRATED IMPLEMENTATION APPROACH:

1. FOUNDATION (Use existing reality):
   - Integrate with existing EconomyState entity/DAO/repository
   - Use existing ChildProfile entities  
   - Build on existing MerlinDatabase

2. MOVE & INTEGRATE RECOVERY FILE:
   - Move LocalEconomyService_recovery.kt to data/src/main/java/com/example/merlin/data/service/
   - Fix package declarations and imports
   - Test build integration

3. BASIC ENTITY LAYER (extend existing):
   - Add Transaction entity to store transaction history
   - Add TransactionDao with essential queries
   - Add TransactionRepository following existing patterns

4. SERVICE INTEGRATION:
   - Wire LocalEconomyService to existing dependency injection
   - Integrate with existing game completion flow
   - Test basic coin earning/spending functionality

5. CORE FEATURES:
   - Implement 1 MC = 1 second conversion
   - Age-based daily caps (30/45/60 min)
   - Basic reward calculation (difficulty-based)
   - Simple spending mechanism

DELIVERABLE: Working economy system that awards coins for task completion and allows spending on screen time. Integrated with existing codebase, no shadow architectures.

## 2. Basic UI & Screen Time Integration [pending]
### Dependencies: 7.1
### Description: Create minimal UI to display wallet balance and implement screen time spending mechanism
### Details:
PRACTICAL UI IMPLEMENTATION:

1. WALLET DISPLAY:
   - Add balance display to existing lock screen
   - Show MC balance and time equivalent (e.g., "150 MC (2m 30s)")
   - Simple, child-friendly display

2. SCREEN TIME SPENDING:
   - Basic spending UI when child wants to unlock screen time
   - Category selection (Entertainment 1:1, Educational 0.8:1, etc.)
   - Time amount selection (5min, 10min, 15min, 30min buttons)
   - Simple "Spend MC" confirmation

3. INTEGRATION POINTS:
   - Hook into existing unlock/lock screen flow
   - Connect to existing accessibility service
   - Integrate with existing parent dashboard (show spending)

4. BASIC NOTIFICATIONS:
   - Simple coin earning notifications ("You earned 45 MC!")
   - Balance warnings ("Only 30 MC left - earn more!")

DELIVERABLE: Working UI that lets kids see their balance, spend coins on screen time, and get basic feedback. No fancy gamification yet - just core functionality.

## 3. Gamification Layer & Parent Dashboard [pending]
### Dependencies: 7.2
### Description: Add badge system, XP progression, and parent analytics once core economy is proven working
### Details:
ENHANCEMENT LAYER (AFTER CORE WORKS):

1. BADGE SYSTEM:
   - Basic achievement badges (first task, 10 tasks, streak days)
   - Simple badge display in wallet UI
   - Badge earning notifications

2. XP & LEVELING:
   - Basic XP system tied to coin earning
   - Simple level progression (1-10 levels)
   - Level-up celebrations

3. PARENT DASHBOARD FEATURES:
   - Economy overview (earning/spending patterns)
   - Transaction history
   - Weekly/monthly reports
   - Daily cap adjustments

4. ADAPTIVE DIFFICULTY FOUNDATION:
   - Basic performance tracking
   - Simple difficulty adjustment (easy/medium/hard)
   - Success rate monitoring toward 80% target

5. POLISH & ANALYTICS:
   - Transaction history and reporting
   - Usage analytics for improvements
   - Performance optimizations

DELIVERABLE: Full gamification layer with badges, XP, and parent insights. Only built after core economy system is proven and working.

