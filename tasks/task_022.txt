# Task ID: 22
# Title: Amazon Affiliate Integration for Real-World Rewards
# Status: pending
# Dependencies: 7, 8
# Priority: medium
# Description: Implement a system that allows children to convert Merlin Coins (MC) to real purchases through Amazon affiliate links with parent approval, using a 25:1 conversion rate (25 MC = 1 cent USD).
# Details:
1. Create AffiliateRewardsManager class to handle MC to USD conversion:
```kotlin
class AffiliateRewardsManager(
    private val database: MerlinDatabase,
    private val amazonAffiliateClient: AmazonAffiliateClient
) {
    companion object {
        const val MC_TO_CENT_RATIO = 25 // 25 MC = 1 cent USD
    }
    
    suspend fun getAvailableBalance(childId: Long): AffiliateBalance {
        val mcBalance = database.economyDao().getChildBalance(childId)
        val usdCents = mcBalance / MC_TO_CENT_RATIO
        return AffiliateBalance(mcBalance, usdCents)
    }
    
    suspend fun createWishlistItem(childId: Long, amazonProductId: String): WishlistItem {
        // Fetch product details from Amazon API
        val productDetails = amazonAffiliateClient.getProductDetails(amazonProductId)
        
        // Create and store wishlist item
        val wishlistItem = WishlistItem(
            id = 0, // Auto-generated
            childId = childId,
            productId = amazonProductId,
            productName = productDetails.name,
            productImageUrl = productDetails.imageUrl,
            priceCents = productDetails.priceCents,
            mcCost = productDetails.priceCents * MC_TO_CENT_RATIO,
            dateAdded = System.currentTimeMillis(),
            status = WishlistStatus.PENDING
        )
        
        val itemId = database.wishlistDao().insertWishlistItem(wishlistItem)
        return wishlistItem.copy(id = itemId)
    }
    
    suspend fun requestPurchase(childId: Long, wishlistItemId: Long): PurchaseRequest {
        // Create purchase request for parent approval
        val wishlistItem = database.wishlistDao().getWishlistItem(wishlistItemId)
        val request = PurchaseRequest(
            id = 0, // Auto-generated
            childId = childId,
            wishlistItemId = wishlistItemId,
            requestDate = System.currentTimeMillis(),
            status = PurchaseRequestStatus.PENDING,
            parentNotes = null
        )
        
        val requestId = database.purchaseRequestDao().insertPurchaseRequest(request)
        return request.copy(id = requestId)
    }
    
    suspend fun approvePurchase(requestId: Long, parentId: Long): PurchaseResult {
        // Process parent approval and execute purchase
        val request = database.purchaseRequestDao().getPurchaseRequest(requestId)
        val wishlistItem = database.wishlistDao().getWishlistItem(request.wishlistItemId)
        val childBalance = database.economyDao().getChildBalance(request.childId)
        
        if (childBalance < wishlistItem.mcCost) {
            return PurchaseResult(success = false, reason = "Insufficient MC balance")
        }
        
        // Deduct MC from child's balance
        database.economyDao().updateChildBalance(request.childId, childBalance - wishlistItem.mcCost)
        
        // Generate affiliate link and record purchase
        val affiliateLink = amazonAffiliateClient.generateAffiliateLink(wishlistItem.productId)
        val purchase = Purchase(
            id = 0, // Auto-generated
            requestId = requestId,
            childId = request.childId,
            parentId = parentId,
            productId = wishlistItem.productId,
            productName = wishlistItem.productName,
            mcCost = wishlistItem.mcCost,
            usdCents = wishlistItem.priceCents,
            purchaseDate = System.currentTimeMillis(),
            affiliateLink = affiliateLink,
            commissionCents = calculateCommission(wishlistItem.priceCents)
        )
        
        val purchaseId = database.purchaseDao().insertPurchase(purchase)
        
        // Update request and wishlist item status
        database.purchaseRequestDao().updateRequestStatus(requestId, PurchaseRequestStatus.APPROVED)
        database.wishlistDao().updateWishlistItemStatus(wishlistItem.id, WishlistStatus.PURCHASED)
        
        return PurchaseResult(
            success = true,
            purchaseId = purchaseId,
            affiliateLink = affiliateLink
        )
    }
    
    suspend fun rejectPurchase(requestId: Long, parentId: Long, reason: String): Boolean {
        // Process parent rejection
        database.purchaseRequestDao().updateRequestStatus(requestId, PurchaseRequestStatus.REJECTED)
        database.purchaseRequestDao().updateParentNotes(requestId, reason)
        return true
    }
    
    private fun calculateCommission(priceCents: Int): Int {
        // Amazon typically offers 1-10% commission depending on product category
        // For simplicity, using 4% as default
        return (priceCents * 0.04).toInt()
    }
}
```

2. Create Amazon Affiliate API client:
```kotlin
class AmazonAffiliateClient(
    private val affiliateTag: String,
    private val apiKey: String,
    private val apiSecret: String
) {
    private val amazonClient = AmazonProductAdvertisingAPIClient(apiKey, apiSecret)
    
    suspend fun getProductDetails(productId: String): ProductDetails {
        // Call Amazon Product Advertising API to get product details
        val response = amazonClient.getItemInfo(productId)
        
        // Parse response and return product details
        return ProductDetails(
            id = productId,
            name = response.title,
            description = response.description,
            imageUrl = response.imageUrl,
            priceCents = convertPriceToCents(response.price),
            ageRestriction = parseAgeRestriction(response.productDetails)
        )
    }
    
    suspend fun searchProducts(query: String, ageRange: IntRange): List<ProductDetails> {
        // Search for age-appropriate products
        val response = amazonClient.searchItems(query)
        
        // Filter products by age appropriateness
        return response.items
            .filter { isAgeAppropriate(it.productDetails, ageRange) }
            .map { item ->
                ProductDetails(
                    id = item.asin,
                    name = item.title,
                    description = item.description,
                    imageUrl = item.imageUrl,
                    priceCents = convertPriceToCents(item.price),
                    ageRestriction = parseAgeRestriction(item.productDetails)
                )
            }
    }
    
    fun generateAffiliateLink(productId: String): String {
        // Generate Amazon affiliate link with tracking tag
        return "https://www.amazon.com/dp/$productId?tag=$affiliateTag"
    }
    
    private fun isAgeAppropriate(productDetails: Map<String, String>, ageRange: IntRange): Boolean {
        // Check if product is appropriate for child's age
        val ageRestriction = parseAgeRestriction(productDetails)
        return ageRestriction == null || ageRange.last >= ageRestriction
    }
    
    private fun parseAgeRestriction(productDetails: Map<String, String>): Int? {
        // Parse age restriction from product details
        val ageString = productDetails["age_range"] ?: return null
        // Extract numeric age value from string like "Ages 13+"
        val ageMatch = Regex("\\d+").find(ageString)
        return ageMatch?.value?.toIntOrNull()
    }
    
    private fun convertPriceToCents(priceString: String): Int {
        // Convert price string like "$12.99" to cents (1299)
        val priceValue = priceString.replace("$", "").toDoubleOrNull() ?: 0.0
        return (priceValue * 100).toInt()
    }
}
```

3. Create database entities and DAOs:
```kotlin
@Entity(tableName = "wishlist_items")
data class WishlistItem(
    @PrimaryKey(autoGenerate = true) val id: Long,
    val childId: Long,
    val productId: String,
    val productName: String,
    val productImageUrl: String,
    val priceCents: Int,
    val mcCost: Int,
    val dateAdded: Long,
    val status: WishlistStatus
)

enum class WishlistStatus {
    PENDING,
    PURCHASED,
    REMOVED
}

@Entity(tableName = "purchase_requests")
data class PurchaseRequest(
    @PrimaryKey(autoGenerate = true) val id: Long,
    val childId: Long,
    val wishlistItemId: Long,
    val requestDate: Long,
    val status: PurchaseRequestStatus,
    val parentNotes: String?
)

enum class PurchaseRequestStatus {
    PENDING,
    APPROVED,
    REJECTED
}

@Entity(tableName = "purchases")
data class Purchase(
    @PrimaryKey(autoGenerate = true) val id: Long,
    val requestId: Long,
    val childId: Long,
    val parentId: Long,
    val productId: String,
    val productName: String,
    val mcCost: Int,
    val usdCents: Int,
    val purchaseDate: Long,
    val affiliateLink: String,
    val commissionCents: Int
)

@Dao
interface WishlistDao {
    @Insert
    suspend fun insertWishlistItem(item: WishlistItem): Long
    
    @Query("SELECT * FROM wishlist_items WHERE childId = :childId AND status = 'PENDING'")
    suspend fun getPendingWishlistItems(childId: Long): List<WishlistItem>
    
    @Query("SELECT * FROM wishlist_items WHERE id = :itemId")
    suspend fun getWishlistItem(itemId: Long): WishlistItem
    
    @Query("UPDATE wishlist_items SET status = :status WHERE id = :itemId")
    suspend fun updateWishlistItemStatus(itemId: Long, status: WishlistStatus)
}

@Dao
interface PurchaseRequestDao {
    @Insert
    suspend fun insertPurchaseRequest(request: PurchaseRequest): Long
    
    @Query("SELECT * FROM purchase_requests WHERE id = :requestId")
    suspend fun getPurchaseRequest(requestId: Long): PurchaseRequest
    
    @Query("SELECT * FROM purchase_requests WHERE childId = :childId AND status = 'PENDING'")
    suspend fun getPendingRequests(childId: Long): List<PurchaseRequest>
    
    @Query("UPDATE purchase_requests SET status = :status WHERE id = :requestId")
    suspend fun updateRequestStatus(requestId: Long, status: PurchaseRequestStatus)
    
    @Query("UPDATE purchase_requests SET parentNotes = :notes WHERE id = :requestId")
    suspend fun updateParentNotes(requestId: Long, notes: String)
}

@Dao
interface PurchaseDao {
    @Insert
    suspend fun insertPurchase(purchase: Purchase): Long
    
    @Query("SELECT * FROM purchases WHERE childId = :childId ORDER BY purchaseDate DESC")
    suspend fun getChildPurchaseHistory(childId: Long): List<Purchase>
    
    @Query("SELECT SUM(commissionCents) FROM purchases")
    suspend fun getTotalCommissionEarned(): Int
}
```

4. Implement UI components for wishlist and purchase management:
```kotlin
@Composable
fun WishlistScreen(
    viewModel: WishlistViewModel,
    navigateToProductDetails: (String) -> Unit
) {
    val wishlistItems by viewModel.wishlistItems.collectAsState()
    val availableBalance by viewModel.availableBalance.collectAsState()
    
    Column(modifier = Modifier.fillMaxSize()) {
        BalanceHeader(
            mcBalance = availableBalance.mcBalance,
            usdCents = availableBalance.usdCents
        )
        
        SearchBar(onSearch = viewModel::searchProducts)
        
        LazyColumn {
            items(wishlistItems) { item ->
                WishlistItemCard(
                    item = item,
                    onItemClick = { navigateToProductDetails(item.productId) },
                    onRequestPurchase = { viewModel.requestPurchase(item.id) }
                )
            }
        }
    }
}

@Composable
fun ParentApprovalScreen(
    viewModel: ParentApprovalViewModel
) {
    val pendingRequests by viewModel.pendingRequests.collectAsState()
    
    Column(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "Pending Purchase Requests",
            style = MaterialTheme.typography.h5,
            modifier = Modifier.padding(16.dp)
        )
        
        LazyColumn {
            items(pendingRequests) { request ->
                PurchaseRequestCard(
                    request = request,
                    onApprove = { viewModel.approvePurchase(request.id) },
                    onReject = { reason -> viewModel.rejectPurchase(request.id, reason) }
                )
            }
        }
    }
}

@Composable
fun PurchaseHistoryScreen(
    viewModel: PurchaseHistoryViewModel
) {
    val purchaseHistory by viewModel.purchaseHistory.collectAsState()
    
    Column(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "Purchase History",
            style = MaterialTheme.typography.h5,
            modifier = Modifier.padding(16.dp)
        )
        
        LazyColumn {
            items(purchaseHistory) { purchase ->
                PurchaseHistoryItem(purchase = purchase)
            }
        }
    }
}
```

5. Implement ViewModels for the affiliate rewards system:
```kotlin
class WishlistViewModel(
    private val affiliateRewardsManager: AffiliateRewardsManager,
    private val childId: Long
) : ViewModel() {
    private val _wishlistItems = MutableStateFlow<List<WishlistItem>>(emptyList())
    val wishlistItems: StateFlow<List<WishlistItem>> = _wishlistItems
    
    private val _availableBalance = MutableStateFlow(AffiliateBalance(0, 0))
    val availableBalance: StateFlow<AffiliateBalance> = _availableBalance
    
    init {
        viewModelScope.launch {
            refreshWishlist()
            refreshBalance()
        }
    }
    
    fun searchProducts(query: String) {
        viewModelScope.launch {
            // Implementation to search products and add to wishlist
        }
    }
    
    fun addToWishlist(productId: String) {
        viewModelScope.launch {
            affiliateRewardsManager.createWishlistItem(childId, productId)
            refreshWishlist()
        }
    }
    
    fun requestPurchase(wishlistItemId: Long) {
        viewModelScope.launch {
            affiliateRewardsManager.requestPurchase(childId, wishlistItemId)
            refreshWishlist()
        }
    }
    
    private suspend fun refreshWishlist() {
        // Fetch updated wishlist items
    }
    
    private suspend fun refreshBalance() {
        _availableBalance.value = affiliateRewardsManager.getAvailableBalance(childId)
    }
}

class ParentApprovalViewModel(
    private val affiliateRewardsManager: AffiliateRewardsManager,
    private val parentId: Long
) : ViewModel() {
    private val _pendingRequests = MutableStateFlow<List<PurchaseRequestWithDetails>>(emptyList())
    val pendingRequests: StateFlow<List<PurchaseRequestWithDetails>> = _pendingRequests
    
    init {
        viewModelScope.launch {
            refreshPendingRequests()
        }
    }
    
    fun approvePurchase(requestId: Long) {
        viewModelScope.launch {
            val result = affiliateRewardsManager.approvePurchase(requestId, parentId)
            if (result.success) {
                refreshPendingRequests()
            }
        }
    }
    
    fun rejectPurchase(requestId: Long, reason: String) {
        viewModelScope.launch {
            affiliateRewardsManager.rejectPurchase(requestId, parentId, reason)
            refreshPendingRequests()
        }
    }
    
    private suspend fun refreshPendingRequests() {
        // Fetch updated pending requests
    }
}
```

6. Integrate with existing MC wallet system:
```kotlin
// Add to EconomyManager.kt
suspend fun convertMCToAffiliateBalance(childId: Long, mcAmount: Int): Boolean {
    val currentBalance = database.economyDao().getChildBalance(childId)
    if (currentBalance < mcAmount) {
        return false
    }
    
    // Deduct MC from child's balance
    database.economyDao().updateChildBalance(childId, currentBalance - mcAmount)
    
    // Record conversion transaction
    val transaction = EconomyTransaction(
        id = 0,
        childId = childId,
        amount = -mcAmount,
        type = TransactionType.AFFILIATE_CONVERSION,
        timestamp = System.currentTimeMillis(),
        description = "Converted to Amazon affiliate balance"
    )
    database.economyDao().insertTransaction(transaction)
    
    return true
}
```

7. Implement secure payment processing and parental controls:
```kotlin
class AffiliateSecurityManager(
    private val database: MerlinDatabase,
    private val encryptionManager: EncryptionManager
) {
    suspend fun verifyParentApproval(requestId: Long, parentPin: String): Boolean {
        val request = database.purchaseRequestDao().getPurchaseRequest(requestId)
        val child = database.childProfileDao().getChildById(request.childId)
        val parent = database.parentProfileDao().getParentByChildId(child.id)
        
        // Verify parent PIN
        return encryptionManager.verifyPin(parentPin, parent.pinHash)
    }
    
    suspend fun isProductAgeAppropriate(productId: String, childId: Long): Boolean {
        val child = database.childProfileDao().getChildById(childId)
        val product = database.productDao().getProductById(productId)
        
        // Check if product age restriction is appropriate for child
        return product.ageRestriction == null || 
               child.age >= product.ageRestriction
    }
    
    suspend fun logPurchaseAttempt(childId: Long, productId: String, success: Boolean) {
        val securityLog = SecurityLog(
            id = 0,
            childId = childId,
            action = if (success) "PURCHASE_SUCCESS" else "PURCHASE_ATTEMPT",
            details = "Product: $productId",
            timestamp = System.currentTimeMillis()
        )
        database.securityLogDao().insertLog(securityLog)
    }
}
```

8. Implement analytics for affiliate commission tracking:
```kotlin
class AffiliateAnalyticsManager(private val database: MerlinDatabase) {
    suspend fun getTotalCommissionEarned(): Int {
        return database.purchaseDao().getTotalCommissionEarned()
    }
    
    suspend fun getMonthlyCommissionReport(): Map<String, Int> {
        val purchases = database.purchaseDao().getAllPurchases()
        
        // Group purchases by month and sum commissions
        return purchases.groupBy { purchase ->
            val date = Date(purchase.purchaseDate)
            val formatter = SimpleDateFormat("yyyy-MM")
            formatter.format(date)
        }.mapValues { (_, purchases) ->
            purchases.sumOf { it.commissionCents }
        }
    }
    
    suspend fun getPopularProductCategories(): Map<String, Int> {
        val purchases = database.purchaseDao().getAllPurchases()
        
        // Group purchases by product category and count
        return purchases.groupBy { purchase ->
            database.productDao().getProductCategory(purchase.productId)
        }.mapValues { (_, purchases) ->
            purchases.size
        }
    }
}
```

9. Update the navigation graph to include new screens:
```kotlin
@Composable
fun AffiliateRewardsNavGraph(
    navController: NavHostController,
    affiliateRewardsManager: AffiliateRewardsManager
) {
    NavHost(
        navController = navController,
        startDestination = "wishlist"
    ) {
        composable("wishlist") {
            val viewModel: WishlistViewModel = viewModel(
                factory = WishlistViewModelFactory(affiliateRewardsManager, childId)
            )
            WishlistScreen(
                viewModel = viewModel,
                navigateToProductDetails = { productId ->
                    navController.navigate("product_details/$productId")
                }
            )
        }
        
        composable("product_details/{productId}") { backStackEntry ->
            val productId = backStackEntry.arguments?.getString("productId") ?: ""
            val viewModel: ProductDetailsViewModel = viewModel(
                factory = ProductDetailsViewModelFactory(affiliateRewardsManager, childId, productId)
            )
            ProductDetailsScreen(
                viewModel = viewModel,
                onAddToWishlist = {
                    navController.popBackStack()
                }
            )
        }
        
        composable("parent_approval") {
            val viewModel: ParentApprovalViewModel = viewModel(
                factory = ParentApprovalViewModelFactory(affiliateRewardsManager, parentId)
            )
            ParentApprovalScreen(viewModel = viewModel)
        }
        
        composable("purchase_history") {
            val viewModel: PurchaseHistoryViewModel = viewModel(
                factory = PurchaseHistoryViewModelFactory(affiliateRewardsManager, childId)
            )
            PurchaseHistoryScreen(viewModel = viewModel)
        }
    }
}

# Test Strategy:
1. Unit Testing:
   - Test MC to USD conversion logic:
     ```kotlin
     @Test
     fun testMCToUSDConversion() {
         val manager = AffiliateRewardsManager(mockDatabase, mockAmazonClient)
         val balance = runBlocking { manager.getAvailableBalance(1L) }
         
         // Assuming child has 1000 MC
         assertEquals(1000, balance.mcBalance)
         assertEquals(40, balance.usdCents) // 1000 MC / 25 = 40 cents
     }
     ```
   
   - Test wishlist item creation:
     ```kotlin
     @Test
     fun testCreateWishlistItem() {
         val manager = AffiliateRewardsManager(mockDatabase, mockAmazonClient)
         val wishlistItem = runBlocking { 
             manager.createWishlistItem(1L, "B08N5KWB9H") 
         }
         
         assertEquals("B08N5KWB9H", wishlistItem.productId)
         assertEquals(WishlistStatus.PENDING, wishlistItem.status)
         // Verify MC cost calculation (price * 25)
         assertEquals(wishlistItem.priceCents * 25, wishlistItem.mcCost)
     }
     ```
   
   - Test purchase approval flow:
     ```kotlin
     @Test
     fun testApprovePurchase() {
         val manager = AffiliateRewardsManager(mockDatabase, mockAmazonClient)
         val result = runBlocking { 
             manager.approvePurchase(1L, 1L) 
         }
         
         assertTrue(result.success)
         assertNotNull(result.affiliateLink)
         assertTrue(result.affiliateLink.contains("tag="))
     }
     ```
   
   - Test insufficient balance rejection:
     ```kotlin
     @Test
     fun testInsufficientBalanceRejection() {
         val manager = AffiliateRewardsManager(mockDatabase, mockAmazonClient)
         // Setup mock to return insufficient balance
         
         val result = runBlocking { 
             manager.approvePurchase(2L, 1L) 
         }
         
         assertFalse(result.success)
         assertEquals("Insufficient MC balance", result.reason)
     }
     ```

2. Integration Testing:
   - Test database integration:
     ```kotlin
     @Test
     fun testDatabaseIntegration() {
         val database = Room.inMemoryDatabaseBuilder(
             context,
             MerlinDatabase::class.java
         ).build()
         
         runBlocking {
             // Insert test data
             val childId = database.childProfileDao().insertChild(testChild)
             val wishlistItemId = database.wishlistDao().insertWishlistItem(testWishlistItem)
             
             // Verify retrieval
             val items = database.wishlistDao().getPendingWishlistItems(childId)
             assertEquals(1, items.size)
             assertEquals(wishlistItemId, items[0].id)
         }
     }
     ```
   
   - Test Amazon API integration:
     ```kotlin
     @Test
     fun testAmazonApiIntegration() {
         val client = AmazonAffiliateClient(
             affiliateTag = "test-tag",
             apiKey = "test-key",
             apiSecret = "test-secret"
         )
         
         runBlocking {
             // Use mock server for Amazon API responses
             val productDetails = client.getProductDetails("B08N5KWB9H")
             
             assertNotNull(productDetails)
             assertEquals("B08N5KWB9H", productDetails.id)
             assertTrue(productDetails.priceCents > 0)
         }
     }
     ```
   
   - Test end-to-end purchase flow:
     ```kotlin
     @Test
     fun testEndToEndPurchaseFlow() {
         val manager = AffiliateRewardsManager(database, amazonClient)
         
         runBlocking {
             // 1. Add item to wishlist
             val wishlistItem = manager.createWishlistItem(childId, "B08N5KWB9H")
             
             // 2. Request purchase
             val request = manager.requestPurchase(childId, wishlistItem.id)
             assertEquals(PurchaseRequestStatus.PENDING, request.status)
             
             // 3. Approve purchase
             val result = manager.approvePurchase(request.id, parentId)
             assertTrue(result.success)
             
             // 4. Verify MC balance deduction
             val newBalance = database.economyDao().getChildBalance(childId)
             assertEquals(initialBalance - wishlistItem.mcCost, newBalance)
             
             // 5. Verify purchase record
             val purchases = database.purchaseDao().getChildPurchaseHistory(childId)
             assertEquals(1, purchases.size)
             assertEquals(wishlistItem.productId, purchases[0].productId)
         }
     }
     ```

3. UI Testing:
   - Test wishlist screen:
     ```kotlin
     @Test
     fun testWishlistScreen() {
         // Setup test data and mock viewModel
         
         composeTestRule.setContent {
             WishlistScreen(
                 viewModel = mockViewModel,
                 navigateToProductDetails = {}
             )
         }
         
         // Verify balance display
         composeTestRule.onNodeWithText("1000 MC").assertIsDisplayed()
         composeTestRule.onNodeWithText("$0.40 USD").assertIsDisplayed()
         
         // Verify wishlist items
         composeTestRule.onNodeWithText("Test Product").assertIsDisplayed()
         composeTestRule.onNodeWithText("250 MC").assertIsDisplayed()
     }
     ```
   
   - Test parent approval screen:
     ```kotlin
     @Test
     fun testParentApprovalScreen() {
         // Setup test data and mock viewModel
         
         composeTestRule.setContent {
             ParentApprovalScreen(viewModel = mockViewModel)
         }
         
         // Verify pending requests
         composeTestRule.onNodeWithText("Pending Purchase Requests").assertIsDisplayed()
         composeTestRule.onNodeWithText("Test Product").assertIsDisplayed()
         
         // Test approve button
         composeTestRule.onNodeWithText("Approve").performClick()
         verify(mockViewModel).approvePurchase(1L)
         
         // Test reject button
         composeTestRule.onNodeWithText("Reject").performClick()
         composeTestRule.onNodeWithTag("rejection_reason").performTextInput("Too expensive")
         composeTestRule.onNodeWithText("Confirm").performClick()
         verify(mockViewModel).rejectPurchase(2L, "Too expensive")
     }
     ```

4. Security Testing:
   - Test age-appropriate filtering:
     ```kotlin
     @Test
     fun testAgeAppropriateFiltering() {
         val securityManager = AffiliateSecurityManager(database, encryptionManager)
         
         runBlocking {
             // Test with 8-year-old child and 13+ product
             val isAppropriate = securityManager.isProductAgeAppropriate("B08ADULT", 1L)
             assertFalse(isAppropriate)
             
             // Test with 8-year-old child and 7+ product
             val isAppropriate2 = securityManager.isProductAgeAppropriate("B08CHILD", 1L)
             assertTrue(isAppropriate2)
         }
     }
     ```
   
   - Test parent PIN verification:
     ```kotlin
     @Test
     fun testParentPinVerification() {
         val securityManager = AffiliateSecurityManager(database, encryptionManager)
         
         runBlocking {
             val isVerified = securityManager.verifyParentApproval(1L, "1234")
             assertTrue(isVerified)
             
             val isVerified2 = securityManager.verifyParentApproval(1L, "wrong")
             assertFalse(isVerified2)
         }
     }
     ```

5. Performance Testing:
   - Test large wishlist loading:
     ```kotlin
     @Test
     fun testLargeWishlistPerformance() {
         // Insert 100 wishlist items
         runBlocking {
             for (i in 1..100) {
                 database.wishlistDao().insertWishlistItem(createTestItem(i))
             }
         }
         
         // Measure time to load wishlist
         val startTime = System.currentTimeMillis()
         runBlocking {
             val items = database.wishlistDao().getPendingWishlistItems(1L)
             assertEquals(100, items.size)
         }
         val endTime = System.currentTimeMillis()
         
         // Should load in under 100ms
         assertTrue(endTime - startTime < 100)
     }
     ```

6. Manual Testing:
   - Verify the complete purchase flow from a child's perspective:
     1. Browse Amazon products through the app
     2. Add items to wishlist
     3. Request purchase with MC
     4. Wait for parent approval
     5. Verify MC balance deduction
     6. Access Amazon purchase through affiliate link
   
   - Verify the parent approval workflow:
     1. Receive notification of pending purchase request
     2. Review request details including MC cost and USD value
     3. Approve or reject with reason
     4. Verify child notification of decision
   
   - Test edge cases:
     1. Attempt to purchase item with insufficient MC balance
     2. Try to purchase age-inappropriate items
     3. Test behavior when Amazon API is unavailable
     4. Verify handling of price changes between wishlist addition and purchase
