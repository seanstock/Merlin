# Task ID: 3
# Title: Database Schema Implementation with Room and SQLCipher
# Status: done
# Dependencies: 1
# Priority: high
# Description: Design and implement the encrypted SQLite database schema using Room ORM and SQLCipher for secure storage of all application data.
# Details:
1. Implement Room Database with SQLCipher integration:
```kotlin
@Database(
    entities = [
        ChildProfile::class,
        TaskHistory::class,
        GameHistory::class,
        ChatHistory::class,
        Memory::class,
        SubjectMastery::class,
        EconomyState::class,
        DailyUsageLog::class,
        ParentSettings::class,
        DeviceState::class
    ],
    version = 1
)
abstract class MerlinDatabase : RoomDatabase() {
    abstract fun childProfileDao(): ChildProfileDao
    abstract fun taskHistoryDao(): TaskHistoryDao
    // Additional DAOs...
}
```

2. Create entity classes for all tables specified in PRD section 3
3. Implement DAOs with appropriate queries for each entity
4. Set up database encryption using SQLCipher with keys stored in Android Keystore
5. Create database migration strategy for future updates
6. Implement repository pattern for clean data access

# Test Strategy:
Write unit tests for all DAOs using in-memory database. Verify encryption is working by attempting to access database file directly. Test database migrations to ensure data integrity across version changes.

# Subtasks:
## 1. SQLCipher Integration Setup [done]
### Dependencies: None
### Description: Integrate SQLCipher with Room by adding necessary dependencies, configuring SafeHelperFactory, and updating the RoomDatabase builder to use SQLCipher for encryption.
### Details:
Add 'net.zetetic:android-database-sqlcipher' and 'androidx.security:security-crypto' dependencies. Configure SupportFactory (or SafeHelperFactory) with the encryption key and pass it to RoomDatabase.Builder via openHelperFactory().
<info added on 2025-05-27T22:13:18.441Z>
1. **Add Dependencies to `:data` Module (`Merlin/data/build.gradle.kts`):**
   * Ensure Room dependencies are present (runtime, ktx, compiler via kapt).
   * Add SQLCipher: `implementation("net.zetetic:android-database-sqlcipher:4.5.3")` (using a recent version).
   * Add AndroidX Security Crypto: `implementation("androidx.security:security-crypto:1.1.0-alpha06")` (or latest suitable version).
   * If `Merlin/data/build.gradle.kts` doesn't exist or is not an Android library, configure it appropriately.

2. **Create Skeleton `MerlinDatabase.kt` in `:data` Module:**
   * Path: `Merlin/data/src/main/java/com/example/merlin/database/MerlinDatabase.kt` (adjust path based on actual package structure).
   * Create minimal abstract class extending RoomDatabase with commented-out @Database annotation.
   * Leave placeholders for entities and DAOs to be added in later subtasks.

3. **Plan Database Instantiation with SQLCipher:**
   * Note that actual instantiation code will go into a dependency injection module or singleton provider.
   * Prepare key configuration snippet showing how to use SupportFactory with Room.databaseBuilder.
   * Mark the passphrase as a critical placeholder to be replaced by secure key management in Subtask 3.4.

4. **Ensure `:app` Module Depends on `:data` Module:**
   * Verify in `Merlin/app/build.gradle.kts` that `implementation(project(":data"))` exists.

5. **Initial Sync/Build Check:**
   * After adding dependencies, attempt a Gradle sync to ensure libraries are resolved.
   * No runtime functionality is expected from this subtask, only correct library setup.
</info added on 2025-05-27T22:13:18.441Z>

## 2. Entity Class Creation [done]
### Dependencies: 3.1
### Description: Define Room entity classes for all specified tables, including appropriate fields, data types, and annotations.
### Details:
Create @Entity-annotated data classes for each table, specifying primary keys, indices, and relationships as needed.
<info added on 2025-05-27T22:17:37.990Z>
# Room Entity Implementation Plan

## General Guidelines
- All entities will be Kotlin data classes
- Package: `com.example.merlin.data.database.entities`
- Field names will match SQL schema with appropriate Room annotations
- Data types:
  - Timestamps: `Long` type
  - Booleans: `Int` (0 or 1) or `Boolean`
  - JSON data: `String` type

## Entities to Create

1. **ChildProfile.kt**
   - Primary key: `id: String`
   - Fields for name, birthdate, age, gender, preferred language, location

2. **ParentSettings.kt**
   - Primary key: `childId: String`
   - Configuration stored as JSON string

3. **TaskHistory.kt**
   - Auto-generated primary key
   - Fields for tracking task completion, correctness, and metadata

4. **GameHistory.kt**
   - Auto-generated primary key
   - Fields for tracking game sessions, levels, results, and timing

5. **ChatHistory.kt**
   - Auto-generated primary key
   - Indexed by child_id and timestamp
   - Fields for role, content, and timestamp

6. **Memory.kt**
   - Auto-generated primary key
   - Fields for storing memory text and sentiment analysis

7. **SubjectMastery.kt**
   - Composite primary key: childId + subject
   - Fields for tracking grade estimates and adaptive difficulty

8. **EconomyState.kt**
   - Primary key: `childId: String`
   - Fields for tracking rewards, streaks, and game economy

9. **DailyUsageLog.kt**
   - Composite primary key: childId + date
   - Tracks daily app usage time

10. **DeviceState.kt**
    - Primary key: `key: String`
    - Simple key-value storage

## Implementation Steps
1. Create the package structure
2. Implement each entity with proper annotations
3. Ensure correct nullability based on SQL schema
4. Update MerlinDatabase.kt to include all entities
</info added on 2025-05-27T22:17:37.990Z>

## 3. DAO Interface Implementation [done]
### Dependencies: 3.2
### Description: Implement DAO interfaces with required queries for CRUD operations and any custom queries needed by the application.
### Details:
Define @Dao interfaces with @Insert, @Update, @Delete, and @Query methods for each entity. Ensure queries are optimized and cover all use cases.
<info added on 2025-05-27T22:29:21.376Z>
# DAO Interface Implementation Plan

## General DAO Structure
- All DAOs will be interfaces within the `com.example.merlin.data.database.dao` package
- Each interface will be annotated with `@Dao`
- Standard CRUD operations will be provided: Insert, Update, Delete, GetById (or equivalent), GetAll
- Return types for read operations will generally be `Entity?` for single items, `List<Entity>` for multiple, or `Flow<List<Entity>>` for observable queries
- `@Insert(onConflict = OnConflictStrategy.REPLACE)` will be used for inserts/updates to handle conflicts

## DAO Definitions

1. **`ChildProfileDao.kt`**
   - `@Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(childProfile: ChildProfile)`
   - `@Update suspend fun update(childProfile: ChildProfile)`
   - `@Delete suspend fun delete(childProfile: ChildProfile)`
   - `@Query("SELECT * FROM child_profile WHERE id = :id") fun getById(id: String): ChildProfile?`
   - `@Query("SELECT * FROM child_profile") fun getAll(): List<ChildProfile>`

2. **`ParentSettingsDao.kt`**
   - `@Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(parentSettings: ParentSettings)`
   - `@Update suspend fun update(parentSettings: ParentSettings)`
   - `@Query("SELECT * FROM parent_settings WHERE child_id = :childId") fun getByChildId(childId: String): ParentSettings?`

3. **`TaskHistoryDao.kt`**
   - `@Insert suspend fun insert(taskHistory: TaskHistory): Long`
   - `@Query("SELECT * FROM task_history WHERE child_id = :childId ORDER BY ts DESC") fun getForChild(childId: String): List<TaskHistory>`
   - `@Query("SELECT * FROM task_history WHERE id = :id") fun getById(id: Long): TaskHistory?`

4. **`GameHistoryDao.kt`**
   - `@Insert suspend fun insert(gameHistory: GameHistory): Long`
   - `@Query("SELECT * FROM game_history WHERE child_id = :childId ORDER BY ts DESC") fun getForChild(childId: String): List<GameHistory>`

5. **`ChatHistoryDao.kt`**
   - `@Insert suspend fun insert(chatHistory: ChatHistory): Long`
   - `@Query("SELECT * FROM chat_history WHERE child_id = :childId ORDER BY ts DESC LIMIT :limit") fun getRecentForChild(childId: String, limit: Int = 20): List<ChatHistory>`
   - `@Query("DELETE FROM chat_history WHERE child_id = :childId AND ts < :timestamp") suspend fun deleteOlderThan(childId: String, timestamp: Long)`

6. **`MemoryDao.kt`**
   - `@Insert suspend fun insert(memory: Memory): Long`
   - `@Query("SELECT * FROM memories WHERE child_id = :childId ORDER BY ts DESC") fun getForChild(childId: String): List<Memory>`

7. **`SubjectMasteryDao.kt`**
   - `@Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(subjectMastery: SubjectMastery)`
   - `@Update suspend fun update(subjectMastery: SubjectMastery)`
   - `@Query("SELECT * FROM subject_mastery WHERE child_id = :childId AND subject = :subject") fun getByChildAndSubject(childId: String, subject: String): SubjectMastery?`
   - `@Query("SELECT * FROM subject_mastery WHERE child_id = :childId") fun getForChild(childId: String): List<SubjectMastery>`

8. **`EconomyStateDao.kt`**
   - `@Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(economyState: EconomyState)`
   - `@Update suspend fun update(economyState: EconomyState)`
   - `@Query("SELECT * FROM economy_state WHERE child_id = :childId") fun getByChildId(childId: String): EconomyState?`

9. **`DailyUsageLogDao.kt`**
   - `@Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(dailyUsageLog: DailyUsageLog)`
   - `@Query("SELECT * FROM daily_usage_log WHERE child_id = :childId AND date = :date") fun getByChildAndDate(childId: String, date: String): DailyUsageLog?`
   - `@Query("SELECT * FROM daily_usage_log WHERE child_id = :childId ORDER BY date DESC") fun getForChild(childId: String): List<DailyUsageLog>`

10. **`DeviceStateDao.kt`**
    - `@Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(deviceState: DeviceState)`
    - `@Query("SELECT * FROM device_state WHERE key = :key") fun getByKey(key: String): DeviceState?`
    - `@Query("SELECT value FROM device_state WHERE key = :key") fun getValueByKey(key: String): String?`

## Implementation Steps
1. Create the package `com.example.merlin.data.database.dao`
2. Create each Kotlin interface file for the DAOs within this package
3. Define the methods with appropriate annotations as planned
4. Add abstract methods for each DAO in `MerlinDatabase.kt`
</info added on 2025-05-27T22:29:21.376Z>

## 4. Encryption Key Management [done]
### Dependencies: 3.1
### Description: Implement secure encryption key management using Android Keystore and the androidx security-crypto library.
### Details:
Generate and store the SQLCipher passphrase securely using Android Keystore. Retrieve and use this key when initializing the SupportFactory for the encrypted Room database.
<info added on 2025-05-27T22:32:59.876Z>
# Encryption Key Management Implementation Plan

## Goal
Securely generate, store, and retrieve the passphrase for SQLCipher using Android Keystore via the `androidx.security:security-crypto` library.

## Implementation Steps

### 1. Define Constants
In a suitable constants file or within the `DatabaseKeyProvider`:
- `KEYSTORE_MASTER_KEY_ALIAS`: A fixed alias for the master key in Android Keystore (e.g., `_androidx_security_master_key_`).
- `ENCRYPTED_PREFS_FILE_NAME`: e.g., `"merlin_secure_database_prefs"`.
- `ENCRYPTED_PASSPHRASE_KEY`: Key for storing the encrypted passphrase within `EncryptedSharedPreferences`, e.g., `"db_passphrase"`.

### 2. Create DatabaseKeyProvider.kt
Location: `Merlin/data/src/main/java/com/example/merlin/data/security/DatabaseKeyProvider.kt`.

Implement as a singleton object with the following method:
```kotlin
fun getOrCreatePassphrase(context: Context): ByteArray {
    val masterKeyAlias = MasterKeys.getOrCreate(MasterKey.AES256_GCM_SPEC)
    
    val sharedPreferences = EncryptedSharedPreferences.create(
        context.applicationContext,
        ENCRYPTED_PREFS_FILE_NAME,
        masterKeyAlias,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    val existingPassphraseBase64 = sharedPreferences.getString(ENCRYPTED_PASSPHRASE_KEY, null)
    if (existingPassphraseBase64 != null) {
        Log.d("DatabaseKeyProvider", "Found existing passphrase.")
        return Base64.decode(existingPassphraseBase64, Base64.DEFAULT)
    }
    
    Log.d("DatabaseKeyProvider", "No existing passphrase found. Generating new one.")
    val newPassphraseBytes = ByteArray(32) // Generate 32 random bytes for a strong key
    SecureRandom().nextBytes(newPassphraseBytes)
    val newPassphraseBase64 = Base64.encodeToString(newPassphraseBytes, Base64.DEFAULT)

    sharedPreferences.edit()
        .putString(ENCRYPTED_PASSPHRASE_KEY, newPassphraseBase64)
        .apply()
    Log.d("DatabaseKeyProvider", "New passphrase generated and stored.")
    return newPassphraseBytes
}
```

Required imports:
- `android.security.keystore.MasterKeys`
- `androidx.security.crypto.EncryptedSharedPreferences`
- `java.security.SecureRandom`
- `android.util.Base64`
- `android.util.Log`

### 3. Integration with Database Instantiation
The passphrase will be used when initializing the SupportFactory for SQLCipher:
```kotlin
val passphraseBytes = DatabaseKeyProvider.getOrCreatePassphrase(applicationContext)
val factory = SupportFactory(passphraseBytes)
Room.databaseBuilder(..., "merlin_encrypted.db").openHelperFactory(factory).build()
```

### 4. Error Handling & Security Notes
- `androidx.security:security-crypto` handles most Keystore complexities
- 32 random bytes provides a strong passphrase
- The passphrase is stored securely in EncryptedSharedPreferences
- Avoid logging the actual passphrase values
- Consider implementing exception handling for rare cases where Keystore might be unavailable

### 5. Testing Considerations
- Verify passphrase creation on first launch
- Verify consistent passphrase retrieval on subsequent launches
- Test behavior when app data is cleared
- Consider edge cases like Keystore unavailability
</info added on 2025-05-27T22:32:59.876Z>

## 5. Repository Layer Implementation [done]
### Dependencies: 3.3, 3.4
### Description: Create a repository layer to abstract data access and provide a clean API for the rest of the application.
### Details:
Implement repository classes that interact with DAOs and handle business logic, ensuring all data access is routed through this layer.
<info added on 2025-05-27T22:34:28.338Z>
# Repository Layer Implementation Plan

## Goal
Create repository classes that abstract data access by using the DAOs implemented in Subtask 3.3. These repositories will provide a clean API for the domain/presentation layers.

## Implementation Details

### 1. Create Repository Package
- Path: `Merlin/data/src/main/java/com/example/merlin/data/repository`

### 2. Implement Repository Classes
- For each DAO, create a corresponding repository class
- Each repository will take its DAO as a constructor parameter (for dependency injection)
- Methods in repositories will generally call the corresponding DAO methods
- Initially, use `suspend` for write operations and direct return types (or `Flow` for reactive reads where appropriate) for read operations

**Example Structure for `ChildProfileRepository.kt`:**
```kotlin
package com.example.merlin.data.repository

import com.example.merlin.data.database.dao.ChildProfileDao
import com.example.merlin.data.database.entities.ChildProfile

class ChildProfileRepository(private val childProfileDao: ChildProfileDao) {

    suspend fun insert(childProfile: ChildProfile) {
        childProfileDao.insert(childProfile)
    }

    suspend fun update(childProfile: ChildProfile) {
        childProfileDao.update(childProfile)
    }

    suspend fun delete(childProfile: ChildProfile) {
        childProfileDao.delete(childProfile)
    }

    fun getById(id: String): ChildProfile? {
        return childProfileDao.getById(id)
    }

    fun getAll(): List<ChildProfile> {
        return childProfileDao.getAll()
    }
}
```

### 3. List of Repositories to Create (mirroring DAOs)
- `ChildProfileRepository.kt`
- `ParentSettingsRepository.kt`
- `TaskHistoryRepository.kt`
- `GameHistoryRepository.kt`
- `ChatHistoryRepository.kt`
- `MemoryRepository.kt`
- `SubjectMasteryRepository.kt`
- `EconomyStateRepository.kt`
- `DailyUsageLogRepository.kt`
- `DeviceStateRepository.kt`

### 4. Business Logic Note
- For this initial implementation, repositories will primarily delegate to DAOs
- More complex business logic (e.g., data transformations, combining data from multiple sources) can be added later or in UseCases within the domain layer

### 5. Dependency Injection (DI) Plan
- These repositories, along with their DAO dependencies and the `MerlinDatabase` instance (using `DatabaseKeyProvider`), will be provided through a DI framework like Hilt or Koin in a later setup phase
- This subtask focuses on creating the repository classes themselves

## Implementation Steps
1. Create the package `com.example.merlin.data.repository`
2. Create each Kotlin class file for the repositories within this package
3. Implement the constructor to accept the corresponding DAO
4. Implement methods that call DAO methods, using `suspend` for suspending DAO functions
</info added on 2025-05-27T22:34:28.338Z>

## 6. Database Migration Strategy Setup [done]
### Dependencies: 3.1, 3.2, 3.3
### Description: Design and implement a migration strategy to handle schema changes and, if needed, migration from unencrypted to encrypted databases.
### Details:
Define Room Migration objects for schema changes. If migrating from a plaintext database, use sqlcipher_export to encrypt existing data and handle migration errors.
<info added on 2025-05-27T22:37:42.671Z>
# Database Migration Strategy Setup

## 1. Enable Room Schema Export
- Modify `Merlin/data/build.gradle.kts` to add KAPT arguments for Room schema location:
  ```kotlin
  kapt {
      arguments {
          arg("room.schemaLocation", "$projectDir/schemas".toString())
      }
  }
  ```
- Update `MerlinDatabase.kt` to change `exportSchema = false` to `exportSchema = true` in the `@Database` annotation.

## 2. Document Future Migration Process
- Create a `DatabaseMigrations.kt` file in `com.example.merlin.data.database` package with example migration patterns:
  ```kotlin
  companion object {
      // Example: Migration from version 1 to 2
      val MIGRATION_1_2 = object : Migration(1, 2) {
          override fun migrate(db: SupportSQLiteDatabase) {
              // db.execSQL("ALTER TABLE child_profile ADD COLUMN new_column_name TEXT")
          }
      }
      // Add more migrations as needed: MIGRATION_2_3, etc.
  }
  // In database builder: .addMigrations(MIGRATION_1_2 /*, MIGRATION_2_3 */)
  ```

## 3. Document Plaintext to Encrypted Migration
- Add documentation in `MerlinDatabase.kt` regarding the `sqlcipher_export` process:
  ```kotlin
  // Note on Plaintext to SQLCipher Migration (for future reference if ever needed):
  // If migrating an existing *unencrypted* SQLite database to use SQLCipher with Room,
  // the process typically involves:
  // 1. Opening the existing plaintext database.
  // 2. Attaching a new, empty, encrypted SQLCipher database.
  // 3. Using the SQLCipher `sqlcipher_export('main', 'encrypted_db_alias')` command to copy data.
  // 4. Detaching databases and then using the new encrypted database file with Room/SQLCipher.
  // This requires careful file management and is not part of the initial setup for this app,
  // as we are starting directly with an encrypted database.
  ```

## 4. Create Schema Directory
- Ensure the directory `Merlin/data/schemas` exists for Room to generate schema JSON files.

## 5. Build and Verify Schema Export
- After implementing changes, perform a Gradle sync and build the project.
- Verify that Room generates the schema file (e.g., `Merlin/data/schemas/com.example.merlin.database.MerlinDatabase/1.json`).
- Commit the generated schema file to version control.
</info added on 2025-05-27T22:37:42.671Z>

## 7. Initial Database Testing and Performance Optimization [done]
### Dependencies: 3.5, 3.6
### Description: Test the encrypted Room database for correctness and performance, focusing on the impact of indexing on query speed.
### Details:
Write unit and integration tests for database operations. Benchmark indexed vs non-indexed queries, optimize indices, and document performance trade-offs due to SQLCipher encryption.
<info added on 2025-05-27T22:39:49.107Z>
# Initial Database Testing and Performance Optimization Plan

## Goal
Verify the correctness of the Room database setup with SQLCipher encryption, write initial unit tests for DAOs, and consider basic performance aspects.

## Implementation Plan

### 1. Create `DatabaseProvider.kt` (Singleton for `MerlinDatabase` instance)
- Location: `Merlin/data/src/main/java/com/example/merlin/database/DatabaseProvider.kt`
- Responsible for building the `MerlinDatabase` instance
- Will use `DatabaseKeyProvider` for the passphrase
- Will configure SQLCipher `SupportFactory`
- Implementation will include proper singleton pattern with thread safety

### 2. Write Basic DAO Unit Tests
- Location: `Merlin/data/src/test/java/com/example/merlin/data/database/dao/`
- Create test classes for key DAOs (e.g., `ChildProfileDaoTest.kt`, `DeviceStateDaoTest.kt`)
- Use `Room.inMemoryDatabaseBuilder` for isolation without encryption overhead
- Test basic CRUD operations (insert, get, update, delete)
- Use appropriate test runners based on Android context requirements

### 3. Create Integration Test for Encrypted Database
- Location: `Merlin/data/src/androidTest/java/com/example/merlin/data/database/EncryptedDatabaseIntegrationTest.kt`
- Will run on emulator/device
- Use actual encrypted database via `DatabaseProvider.getInstance(context)`
- Perform simple write/read operations to verify encryption functionality
- Confirm SQLCipher integration and key management work correctly

### 4. Performance Considerations & Documentation
- Review entities for necessary indices (beyond automatic primary key indexing)
- Document performance-sensitive queries
- Note general performance impact of SQLCipher encryption
- Defer explicit benchmarking but maintain awareness of performance implications

### 5. Schema Export Verification
- Confirm generation of `Merlin/data/schemas/com.example.merlin.database.MerlinDatabase/1.json`
- Ensure schema file is properly tracked in version control

## Implementation Sequence
1. Create DatabaseProvider.kt
2. Add necessary test dependencies to build.gradle.kts
3. Implement DAO unit tests
4. Implement encrypted database integration test
5. Document performance considerations
</info added on 2025-05-27T22:39:49.107Z>

